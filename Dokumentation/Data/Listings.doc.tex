\renewcommand{\arraystretch}{1.5}
\setlength\intextsep{0pt}
\chapter[Listings \LILLYxBOXxVersion{\small 1.0.0}]{Listings}
\TitleSUB{Ist this\ldots the Matrix? \hfill \LILLYxBOXxVersion{\small 1.0.0}}
\bigskip\newline
\elable{chp:LISTINGS}Zum Setzen von Programmtexten innerhalb von Latexdokumenten stellt dieses Paket eine große Ansammlung verschiedener Sprachen und Dialekten zur Verfügung. Es befindet sich hier:
\begin{center}
    \blankcmd{LILLYxPATHxLISTINGS} = \T{\LILLYxPATHxLISTINGS}
\end{center}

\begin{bemerkung}[Standalone Listings]
    Mit \LILLYxBOXxVersion{2.0.0} wurde die Listings-Integration als eigenes Paket \LILLYxNOTExLibrary{LILLYxLISTINGS} etabliert, welches sich eigenständig über \begin{latex}
\usepackage{LILLYxLISTINGS}
        \end{latex}
        auch ohne das Verwenden der restlichen LILLY-Welt benutzen lässt.
\end{bemerkung}
\textit{%
Sei es nun \fg[], \eidi oder \gdra[], in jeder Vorlesungsreihe war es von Relevanz Quelltexte mit Syntax-Highlighting zu versehen. Hierfür verwendet LILLY die Bibliothek \T{listings} und fügt einige Styles und ein paar Sprachen hinzu, die ebenfalls frei gewählt werden können. Aktuell ist die Implementation an vielen Stellen noch weit weg von perfekt. So ist es in GDRA zum Beispiel immer noch vonnöten das Highlighting, von zum Beispiel \T{addiu}, mithilfe von \T{*\blankcmd{mipsADD}*}einzubinden. An einer Lösung hierfür wird aktuell gearbeitet, siehe weiter \jmark[unten]{jmp:lstCodeInject}.}

\section{Die grundlegenden Eigenschaften}
\subsection{Grundlegendes Design}

Diese Definitionen befinden sich in der Datei: {\ltt\blankcmd{LILLYxPATHxLISTINGS}/LILLYxLISTINGS}. Sie werden mit \LILLYxBOXxVersion{2.0.0} automatisch mit dem Einbinden von \LILLYxNOTExLibrary{LILLYxLISTINGS} geladen.
\begin{bemerkung}[Verwendetes Paket]
    LILLY verwendet nicht das normale \verb|listings|-Paket, sondern greift auf das erweiterte Paket \verb|listingsutf8| zu, sofern dieses Vorhanden ist. Es werden weiter Definitionen für alle Umlaute gesetzt, sowie eine Reihe an weiteren Ersetzungsregeln. Darunter fällt übrigens auch das Markieren von Zahlen.
\end{bemerkung}
Um dynamisch zu bleiben bindet LILLY nicht einfach verschiedene Stile ein, sondern Dateien, welche dann für sich definieren, welche Stile und Sprachen zusätzlich zur Verfügung stehen.%\marginpar{\tiny Bisher ist das Einbinden neuer Stile noch recht starr, da der Dateipfad bis auf das Suffix vorgegeben ist. Dies sollte geändert werden}\par\reversemarginpar
Mithilfe von \blankcmd{LILLYxListingsxLang} kann man das jeweilige Paket auswählen. Dieses Paket wird über den klassischen \blankcmd{input\{\}}-Befehl eingebunden und zwar über folgende Anweisung:
{\small\begin{latex}
\input{\LILLYxPATHxLISTINGS/Packages/_LILLY_PACK_!**!\LILLYxListingsxPACK}
\end{latex}}

Standardmäßig wird so das \T{MAIN}-Paket geladen, welches alle hier definierten Sprachen mitliefert. Damit die zur Verfügung stehenden Sprachen auch verwaltet werden können, läuft die Verwaltung der Sprachen wieder über eine Liste. Die Liste \emph{RegisteredLanguages} verwaltet hierbei die Registrierten Sprachen (in der Signatur \T{Sprache/Sprachbezeichner}) und stellt für jede Sprache einen Shortcut zur Verfügung:\begin{ditemize}
    \item \T{\blankcmd{c<Sprache>}\{<Code>\}} Setzt den Code mit grauem Hintegrund. Zeilenumbrüche werden hier zwar durchgeführt, allerdings in der Regel nicht optimal gesetzt. Beispiel: \begin{latex}
\cjava{public static void main(String[] args)}
    \end{latex}
    Liefert: \cjava{public static void main(String[] args)}
    \item \T{\blankcmd{b<Sprache>}\{<Code>\}} Setzt den Code farbig auf dem vorhandenen Hintegrund. Beispiel: \begin{latex}
\bjava{public static void main(String[] args)}
    \end{latex}
            Liefert: \bjava{public static void main(String[] args)}
    \item \T{\blankcmd{i<Sprache>}\{<Datei>\}} Lädt und setzt den Programmcode aus der entsprechenden Datei.
\end{ditemize}
Ferner \emph{kann} eine Sprache eine gleichnamige Umgebung mitliefern, die das direkte Setzen des Codes innerhalb eines Textlaufes ermöglicht. Beispiel:
\begin{latex}
\begin{java}
public class SuperKlass {
    public static void main(String[] args) {
        System.out.println("Hallo Welt");
    }
}
\end{java}
\end{latex}
Ergibt:
\begin{java}
public class SuperKlass {
    public static void main(String[] args) {
        System.out.println("Hallo Welt");
    }
}
\end{java}

\presentCommand[2.0.0]{isLanguageLoaded}[\manArg{LanguageSignature}]
Prüft ob eine Sprache geladen ist. Als Argument wird hierbei die volle Sprachsignatur erwartet (\T{Sprache/Sprachbezeichner}) um auch doppelten Bezeichnern vorzubeugen.

\presentCommand[2.0.0]{isLanguageNameLoaded}[\manArg{LanguageName}]
\elable{mrk:ilnl}Prüft ob eine Sprache geladen ist. Als Argument wird hierbei die volle Sprache erwartet, was doppelte Bezeichner natürlich ausschließt, allerdings in den meisten Fällen auch einfacher ist:
\begin{latex}
\isLanguageNameLoaded{java} % :yields: TRUE
\isLanguageNameLoaded{waffel} % :yields: FALSE
\end{latex}

\presentCommand[2.0.0]{lstshowcmd}[\manArg{command}]
Kleiner Shortcut um auch den Inhalt eines Befehls als Listing zu setzen. Betrachte folgendes Beispiel:
\begin{latex}
\begin{multicols}{3}
    \begin{ditemize}
        \foreach \x in {public,static,void} {
            \item \cjava{\x} vs. \lstshowcmd[language=lJava]{\x}
        }
    \end{ditemize}
\end{multicols}
\end{latex}
Ergibt:
\begin{multicols}{3}
    \begin{ditemize}
        \foreach \x in {public,static,void} {
            \item \cjava{\x} vs. \lstshowcmd[language=lJava]{\x}
        }
    \end{ditemize}
\end{multicols}

\presentCommand[1.0.8]{LILLYxwriteLst}[\optArg{lstArgs}\manArg{Code}\cmdold]
Setzt Programmcode entsprechend veralteter Definitionen.

\begin{bemerkung}[Zugriff auf die eigentliche Sprachdefinition]
    Um keine Doppeldeutigkeit bezüglich der Sprachen zu erhalten werden alle LILLY-Sprachen durch das \say{\T{l}}-Prefix angeführt. So heißt es nicht \say{\T{java}} sondern \say{\T{lJava}}, sofern die Sprache manuell geladen werden soll.
\end{bemerkung}



% Um sich jeglicher Formatierung eines Pakets zu entziehen definiert \LILLYxNOTExLibrary{LILLYxLISTINGS} noch zwei weitere Umgebungen:
% \presentEnvironment[2.0.0]{nstabbing}[\cmdlist \blankenv{centered}]

\subsection{Das MAIN-Paket}
Diese Definitionen befinden sich in der Datei: {\ltt\blankcmd{LILLYxPATHxLISTINGS}/Packages/\_LILLY\_PACK\_MAIN}. Sie werden mit \LILLYxBOXxVersion{2.0.0} automatisch mit dem Einbinden von \LILLYxNOTExLibrary{LILLYxLISTINGS} geladen.


Nebst der Sprach-Umgebungen werden hier zwei Umgebungen definiert, die dem Stil des Main-Pakets entgegenarbeiten:
\presentEnvironment[1.0.9]{lstplain}[\optArg{lstArgs}\cmdlist \blankenv{lstnonum}\optArg{lstArgs}]
Während erstere einfach nur Code ohne anderweitige Formatierungen setzt, entfernt letztere nur die Aufzählung entsprechender Zahlen:
\begin{latex}
\begin{lstplain}[language=lJava]
public static void main(String[] args) {
    System.out.println("Hallo Welt");
}
\end{lstplain}
% Sowie:
\begin{lstnonum}[language=lJava]
public static void main(String[] args) {
    System.out.println("Hallo Welt");
}
\end{lstnonum}
\end{latex}
Ergibt:
\begin{lstplain}[language=lJava]
public static void main(String[] args) {
    System.out.println("Hallo Welt");
}
\end{lstplain}
Sowie:
\begin{lstnonum}[language=lJava]
public static void main(String[] args) {
    System.out.println("Hallo Welt");
}
\end{lstnonum}

\begin{bemerkung}[Geladene Sprachen]
    Hier eine Auflistung aller Sprachen, die über das Main-Paket geladen werden:\vspace{-0.5\baselineskip}
    \begin{multicols}{4}
        \begin{ditemize}\narrowitems
            \foreach \x in \LISTxRegisteredLanguageNames {\ifthenelse{\equal{\x}{}}{}{\item \x}}
        \end{ditemize}
    \end{multicols}
\end{bemerkung}

Widmen wir uns nun allerdings einmal den weiteren Definitionen des MAIN-Pakets:
Die allgemeine TypeWriter-Schriftart wird mithilfe von \blankcmd{LILLYxlstTypeWriter} auf \T{AnonymousPro} gesetzt (\textit{Sie wird auch hier für die Dokumentation verwendet}). Zudem lädt \T{MAIN} noch das Paket \T{MIPS}, auf welches weiter unten noch weiter eingegangen wird. Weiter wird \verb|\lst@PlaceNumber| modifiziert und es werden einige grundlegende Einstellungen getätigt, welche sich in der linken Tabelle wiederfinden lassen. Im Folgenden werden die einzelnen hierrüber eingebundenen Sprachen nicht weiter beschrieben - hierzu gibt es eigene Sektionen weiter unten\ldots\smallskip\newline

\subsection{Das MIPS-Paket}
Diese Definitionen befinden sich in der Datei: {\ltt\blankcmd{LILLYxPATHxLISTINGS}/Languages/\_LILLY\_LANG\_MIPS}. Sie werden mit \LILLYxBOXxVersion{2.0.0} automatisch mit dem Einbinden von \LILLYxNOTExLibrary{LILLYxLISTINGS} geladen.\newline

Dieses Paket wurde vor allem im Rahmen von \gdra erstellt und bindet das Paket \verb|caption| mit ein, um die Positionierung von Titeln zu vereinfachen.
\presentCommand{gitRAW}[\cmdlist \blankcmd{git}\cmdold]
Fügen mithilfe von FontAwesome ein Github Symbol ein, welches auf ein Github-Repository verweist, indem sich alle in \gdra verwendeten Codes befinden (\url{https://www.github.com/EagleoutIce/MIPS_UniUlm_Examples/}: \git). Ursprünglich waren diese Definitionen nur für \gdra gedacht und sollten auch schleunigst wieder dorthin verschwinden (TODO!)!

Es werden einige weitere Stile definiert:

\paragraph{MIPS} Syntax-Highlighting für alle grundlegende MIPS-Befehle - verwendet $6$ verschiedene Farben für verschiedene Arten von Keywords:
\newcommand{\csXlslave}[2]{\T{#1}${}^{~(#2)}$}
\begin{multicols}{2}
    \begin{itemize}[label=$\diamond$]\narrowitems
        \foreach \c/\l in {Zeichenketten/candypink,
                           Befehle/purple,
                           Register/tealblue,
                           Direktiven/dgold,
                           Spezielle~Befehle/limegreen,
                           Buzzwords/thered,
                           Daten-Direktiven/tealblue!60!black%
                           } {
            \item[\csXshow{\l}] \csXlslave{\c}{\l}
        }
    \end{itemize}
\end{multicols}
Weiter setzt es die Position der Zeilenummern auf die rechte Seite.
\paragraph{MIPSSNIP}
Funktioniert analog zu \T{MIPS}, aber definiert das Design für kurze Ausschnitte.

\begin{bemerkung}[MIPS]
    Das gesamte Mipspaket ist seit \LILLYxBOXxVersion{1.8.0} überholt und bedarf einiger Aufarbeitung, dennoch tut es seinen Dienst für die bisher existenten MIPS-Codes allerdings stehen weitere besonderheiten wie zum Beispiel \jmark[Literates]{mrk:jmpLiterate} nebst der anfänglich implementierten nicht zur Verfügung\ldots
\end{bemerkung}

% \section{Die mitgelieferten Erweiterungen}
% \subsection{assembler}
% {\centering \framebox{Definitionen aus der Datei: \T{Listings/Languages/\_LILLY\_LANG\_assembler}}\vspace*{0.5\baselineskip}\par}

% \begin{wraptable}{L}{0.5\linewidth}
%     \footnotesize\centering\begin{tabular}{|>{\LILLYxlstTypeWriter}l|>{\LILLYxlstTypeWriter}l|}
%             \hline
%                 showstringspaces & true \\\hline
%                 basicstyle & \CMDshow{LILLYxlstTypeWriter} \\\hline
%                 keywordstyle & \CMDshow{color}\{purple\}\CMDshow{bfseries} \\\hline
%                 commentstyle & \CMDshow{color}\{gray\} \\\hline
%                 stringstyle & \CMDshow{color}\{mint\}\\\hline
%                 extendedchars & true \\\hline
%                 comment & [l]\{//\} \\\hline
%                 morecomment & [s]\{/*\}\{*/\} \\\hline
%                 morestring & [b]' \\
%             \hline
%         \end{tabular}
%         \vspace{-50pt}
% \end{wraptable}
% Diese Sprache liefert eine seltsame Mischung an Assembler-Befehlen, die in \gdra zum Teil als Pseudo-Assembler-Befehlssatz verwendet wurden. Die definierten Schlüsselwörter lauten:\smallskip\newline \parbox{0.98\linewidth}{\T{while, if, r, ld, st, sr, sl, beq, bnq, add, sub, and, or, not, xor, dec, inc, jmp, addi, sw, addui, add, sw, lw, slti, j, jal, div, mul, hi, lo}.}\smallskip\newline Weiter werden \T{ndkeywords} definiert \T{nop, X, acc}, mit folgendem Style:\smallskip\newline \T{\CMDshow{color}\{tealblue!80!black\}\CMDshow{bfseries}}.

% \subsection{pseudo}
% {\centering \framebox{Definitionen aus der Datei: \T{Listings/Languages/\_LILLY\_LANG\_pseudo}}\vspace*{0.5\baselineskip}\par}

% \begin{wraptable}{L}{0.5\linewidth}
%     \footnotesize\centering\begin{tabular}{|>{\LILLYxlstTypeWriter}l|>{\LILLYxlstTypeWriter}l|}
%             \hline
%                 showstringspaces & false \\\hline
%                 basicstyle & \CMDshow{LILLYxlstTypeWriter} \\\hline
%                 keywordstyle & \CMDshow{color}\{purple\}\CMDshow{bfseries} \\\hline
%                 commentstyle & \CMDshow{color}\{gray\} \\\hline
%                 stringstyle & \CMDshow{color}\{mint\}\\\hline
%                 extendedchars & true \\\hline
%                 comment & [l]\{//\} \\\hline
%                 morecomment & [s]\{/*\}\{*/\} \\\hline
%                 morestring & [b]' \\
%             \hline
%         \end{tabular}
%         \vspace{-80pt}
% \end{wraptable}
% Diese Sprache liefert die Befehle für die Pseudo-Programmiersprache in \fg[]. Die definierten Schlüsselwörter lauten:\medskip\newline \parbox{0.98\linewidth}{\T{INPUT, REPEAT, ELSE, UNTIL, OR, END, FOR, IF, END, TO, DO, THEN, TRUE, FALSE, END,  print, println, goto, system}.}\vspace{50pt}\newline

% \subsection{pseudo\_nospace \LILLYxNOTExWarning{Veraltet}}
% {\centering \framebox{Definitionen aus der Datei: \T{Listings/Languages/\_LILLY\_LANG\_pseudo\_nospace}}\vspace*{0.5\baselineskip}\par}
% Definiert bis auf die Option \T{sensitive} die selben Dinge wie \T{pseudo} und ist nur noch aus Kompatibilitätsgründen vorhanden.

% \subsection{bash}
% {\centering \framebox{Definitionen aus der Datei: \T{Listings/Languages/\_LILLY\_LANG\_bash}}\vspace*{0.5\baselineskip}\par}

% Dieser Stil wurde für die Dokumentation erstellt und wird mit ihr erweitert und verfeinert. Es ist davon auszugehen, dass alle in dieser Dokumentation verwendeten Befehle zur Verfügung stehen. Bei Bedarf kann dieses Paket gerne erweitert und ausgebaut werden. Bisher definiert es Befehle wie: \T{mkdir, texhash, make, apt}, Parameter wie \T{-p, -dir, print, install} und Dokumentbezeichnern wie: \T{lilly\_compile.sh, sudo}. \begin{center}
%     FunFact: Für Variablen mit \$ wird die Farbe \emph{antiVeg} verwendet (\csXshow{antiVeg} - \#BEEEEF)
% \end{center}

% \subsection{latex}
% {\centering \framebox{Definitionen aus der Datei: \T{Listings/Languages/\_LILLY\_LANG\_latex}}\vspace*{0.5\baselineskip}\par}

% Dieser Stil wurde ebenfalls für die Dokumentation erstellt und wird genauso erweitert und verfeinert. Deswegen wird in diesem Rahmen hier ebenfalls keine vollständige Auflistung stattfinden. Lediglich eine Auflistung der verwendeten Stile für die einzelnen Schlüsselwörter:
% \begin{multicols}{2}
%     \begin{itemize}[label=$\diamond$]\narrowitems
%         \foreach \c/\l/\a/\f in {Zeichenketten/Amber//,
%                            Befehle/black/\CMDshow{bfseries}/thick,
%                            Lilly/Awesome/\CMDshow{bfseries}/thick,
%                            Parameter/Amber//,
%                            Umgebungen/Ao//,
%                            Kommentare/gray//%
%                            } {
%             \item[{\csXshow[\f]{\l}}] \csXlslave{\c}{\l\ifthenelse{\equal{\a}{}}{}{~-~\a}}
%         }
%     \end{itemize}
% \end{multicols}
% Es werden keine Zeilennummern angezeigt.
% \normalmarginpar
\section{Marker und weitere Befehle}
\subsection{Literates}
\elable{mrk:jmpLiterate}Im Kontext verschiedener Programmiersprachen kam bald der Wunsch auf verschiedene Symbole entsprechend einfach Setzen zu können. Bisher werden alle diese Ersetzungsregeln über das Einbinden von \LILLYxNOTExLibrary{LILLYxLISTINGS} geladen und ermöglichen es, neben Umlauten auch Symbole einzubinden. Die Ersetzungsregeln werden nicht über eine Liste gehandhabt und sind ebenso vielfältig wie es die Bedürfnisse erfordern. Im Folgenden eine Auflistung aller in \LILLYxBOXxVersion{2.0.0} enthaltener Ersetzungsregeln:
\begin{multicols}{4}
    \begin{description}
        \foreach \x in {:bs:,:bmath:,:emath:,:dollar:,:space:,:ws:,:cdots:,:cdot:,:ldots:,:c:,:float:,:exp:,:yields:,:lan:,:ran:,:bcmd:} {
            \item[{\T{\x}}] \say{\lstshowcmd{\x}}
        }
    \end{description}
\end{multicols}
\subsection{Marker}
Mit \LILLYxBOXxVersion{2.0.0} im Anfangsstadium befinden sich die jeweiligen Marker die es erlauben Fehler oder ganz Allgemein Code-stellen zu markieren, oder von Highlighting zu befreien:
\begin{java}
|info|import java.util.ArrayList;|info|

|plain|public class Example {|plain|
    public static void main(String[] args) {
        System.out.|err|PrintLn|err|("Hallo Welt");
        if(|warn|args==null|warn|)
            System.out.println("wau");
    }
}
\end{java}
\begin{latex}
\begin{java}
|info|import java.util.ArrayList;|info|

|plain|public class Example {|plain|
    public static void main(String[] args) {
        System.out.|err|PrintLn|err|("Hallo Welt");
        if(|warn|args==null|warn|)
            System.out.println("wau");
    }
}
\end{java}
\end{latex}

\section{Advanced Listings}

Diese Definitionen befinden sich in der Datei: {\ltt\blankcmd{LILLYxPATHxLISTINGS}/LILLYxLISTINGSxADVANCED}. Sie werden mit \LILLYxBOXxVersion{2.0.0} automatisch mit dem Einbinden von \LILLYxNOTExLibrary{LILLYxLISTINGSxADVANCED} geladen.

\presentEnvironment[2.0.0]{presentlst}[\optArg{tcbaddons}\manArg{language}]
Setzt Quellcode in einem modernen Design:
\begin{latex}
\begin{presentlst}{lJava}
public static void main(String[] args) {
    System.out.println("Hallo Welt");
}
\end{presentlst}
\end{latex}
Ergibt:
\begin{presentlst}{lJava}
public static void main(String[] args) {
    System.out.println("Hallo Welt");
}
\end{presentlst}

\presentCommand[2.0.0]{p<lang>}[\manArg{Code}]
Setzt Analog zu \blankcmd{c<lang>} den Code in einer Zeile im entsprechend Design. Hier allerdings ebenfalls das neue, modernere Design:
\begin{latex}
\pcpp{int main(int argc, char** argv)}
\end{latex}
Ergibt: \pcpp{int main(int argc, char** argv)}.
% \begin{slatex}
% \documentclass{article}

% \usepackage{LILLYxLIST}

% \def!**!\fun#1{#1}

% \begin{document}
%     Und alle mögen sie Gänse!**!\ldots oder waren es Gämse?
% \end{document}
% \end{slatex}

% \begin{presentlst}{lJava}
% public static void main(String[] args) {
%     System.out.println("Hallo Welt");
% }
% \end{presentlst}


% Es ist doch toll oder?: \pcpp{int main(int argc, char** argv)}
% \begin{sjava}
% public double calculatePI() {

%     int acc = IntStream.range(0, ITERATIONS-1).map((x) -> {
%         double a = Math.random();
%         double b = Math.random();
%             if (a*a + b*b <= 1.0) return 1;
%             else                  return 0;
%     }).sum();


%     return (4.0 * acc) / ITERATIONS;
% }
% \end{sjava}

\section{Runtimes}
Diese Definitionen befinden sich in der Datei: {\ltt\blankcmd{LILLYxPATHxLISTINGS}/LILLYxRUNTIMES}. Sie werden mit \LILLYxBOXxVersion{2.0.0} automatisch mit dem Einbinden von \LILLYxNOTExLibrary{LILLYxLISTINGSxADVANCED} geladen. Weiter existiert es als eigenständiges Paket \LILLYxNOTExLibrary{LILLYxRUNTIMES}.\medskip\newline
Runtimes bieten die Möglichkeit Code einer Programmiersprache in Latex ausführen zu lassen und das Ergebnis ebenfalls im Latexdokument zu setzen. Hierfür wird eine bereits aufgesetzte Umgebung für die jeweilige Sprache benötigt, LILLY greift also auf einen bestehenden Compiler/Interpreter zurück. Alle mitgelieferten Runtimes befinden sich in der Liste \T{RegisteredRuntimes} und liefern:\newline
%
%
%
\presentCommand[2.0.0]{r<Runtime>}[\optArg{Mid-Text}\manArg{Code}]
Führt den übergebenen Code in der jeweiligen Runtime aus und liefert das Ergebnis. So zum Beispiel mit \T{\blankcmd{rbash}\{ls . | tail -2\}}: \rbash{ls . | tail -2}
\T{\blankcmd{rbash}[liefert:]\{ls . | tail -4\}}: \rbash[liefert:]{ls . | sort | tail -4}
%
%
%
\presentCommand[2.0.0]{isRuntimeLoaded}[\manArg{runtimeName}]
Testet analog zu \jmark[\blankcmd{isLanguageNameLoaded}]{mrk:ilnl} ob eine entsprechende Runtime geladen ist:
\begin{latex}
\isRuntimeLoaded{bash}  % :yields: TRUE
\isRuntimeLoaded{waffel} % :yields: FALSE
\end{latex}
% Won't use inline as this breaks color highlight :D
%
%
%
\begin{bemerkung}[Was es noch so gibt]
    Die Runtimes liefern, bisher noch nicht normiert, auch noch Befehle wie: \blankcmd{previewBashFile}, die eine bestehende Datei ausführen und das Ergebnis ausgeben. An einer Normierung und Erweiterung wird gearbeitet.
\end{bemerkung}
